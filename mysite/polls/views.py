from re import template
from statistics import mode
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from django.db.models import F
from django.utils import timezone
from django.views import generic

from .models import Question,Choice

## Replace index, detail and results views and use Django's generic views instead.

# # Create your views here.
# def index(request):
#     latest_question_list = Question.objects.order_by('-pub_date')[:5]    
#     context = {'latest_question_list':latest_question_list,}       
#     return render(request,'polls/index.html',context)

# def detail(request,question_id):
#     question = get_object_or_404(Question,id=question_id)
#     return render(request,'polls/detail.html',{'question':question})

# def results(request,question_id):
#     question = get_object_or_404(Question,pk=question_id)
#     return render(request,'polls/results.html',{'question':question})


# We're using two generic views here:
# :class:`~django.views.generic.list.ListView` and
# :class:`~django.views.generic.detail.DetailView`. Respectively, those
# two views abstract the concepts of "display a list of objects" and
# "display a detail page for a particular type of object."

# * Each generic view needs to know what model it will be acting
#   upon. This is provided using the ``model`` attribute.

# * The :class:`~django.views.generic.detail.DetailView` generic view
#   expects the primary key value captured from the URL to be called
#   ``"pk"``, so we've changed ``question_id`` to ``pk`` for the generic
#   views.

class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    # For ``DetailView`` the ``question`` variable is provided
    # automatically -- since we're using a Django model (``Question``), Django
    # is able to determine an appropriate name for the context variable.
    # However, for ListView, the automatically generated context variable is
    # ``question_list``. To override this we provide the ``context_object_name``
    # attribute, specifying that we want to use ``latest_question_list`` instead.
    context_object_name = 'latest_question_list'

    def get_queryset(self):
     """Return the last 5 published questions."""
     questions = Question.objects.filter(
         pub_date__lte = timezone.now()
     ).exclude(
         choice=None
     ).order_by('-pub_date')[:5]
     print(questions)
     return questions

class DetailView(generic.DetailView):
    #     By default, the :class:`~django.views.generic.detail.DetailView` generic
    # view uses a template called ``<app name>/<model name>_detail.html``.
    model = Question
    # The ``template_name`` attribute is used to tell Django to use a specific
    # template name instead of the autogenerated default template name.
    template_name = 'polls/detail.html'
    def get_queryset(self):
        return Question.objects.exclude(choice=None).filter(pub_date__lte=timezone.now())
    

class ResultsView(generic.DetailView):
    model = Question
    template_name = 'polls/results.html'
    def get_queryset(self):
        return Question.objects.exclude(choice=None).filter(pub_date__lte=timezone.now())

def vote(request,question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        select_choice = question.choice_set.get(pk=request.POST['choice'])
        #  :attr:`request.POST <django.http.HttpRequest.POST>` is a dictionary-like
        # object that lets you access submitted data by key name. In this case,
        # ``request.POST['choice']`` returns the ID of the selected choice, as a
        # string. :attr:`request.POST <django.http.HttpRequest.POST>` values are
        # always strings.
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(request,'polls/detail.html',{
            'question':question,
            'error_message' : "You didn't select a choice.",
        })
    else:
        # Avoid race condition.
        # Instead of UPDATE choice SET vote = 7 WHERE id = 1
        # We Django generates following SQL: UPDATE choic SET vote = vote + 1 WHERE id = 1
        select_choice.votes = F('votes') + 1
        select_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        
        # reverse - This function helps avoid having to hardcode a URL in the view function.
        # It is given the name of the view that we want to pass control to and the
        # variable portion of the URL pattern that points to that view.
        return HttpResponseRedirect(reverse('polls:results',args=(question_id,)))


